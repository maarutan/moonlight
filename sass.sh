#!/usr/bin/env bash
# ┌─┐┌─┐┌─┐┌─┐    ┌─┐┌─┐┌┬┐┌─┐┬┬  ┌─┐┬─┐
# └─┐├─┤└─┐└─┐    │  │ ││││├─┘││  ├┤ ├┬┘
# └─┘┴ ┴└─┘└─┘────└─┘└─┘┴ ┴┴  ┴┴─┘└─┘┴└─
# --------------------------------------------------------------------
# Copyright (c) 2025 maarutan. \ Marat Arzymatov All Rights Reserved.
# https://github.com/maarutan
# --------------------------------------------------------------------
#
# Script Documentation:
#
# This script automates the management and compilation of Sass styles.
# It performs the following tasks:
# 1. Scans a specified styles directory for Sass component directories.
#    - The directory must either start with "_" or end with "_".
# 2. In each detected directory, it looks for a special "_import.sass" file.
#    - You should put your Sass @use imports in these files.
# 3. Generates a central "import.sass" file in the "styles" folder,
#    collecting all @use statements automatically.
# 4. Provides a menu to either:
#    a) Start watching Sass files for changes and compile to main.css
#    b) Rebuild the import.sass file and show the imports
#    c) Exit the script
# 5. Ensures that node_modules exist and installs Sass if necessary.
#
# How it works:
# - Uses "realpath" to determine relative paths for imports.
# - Uses animation and colored output for better visualization.
# - Handles interruptions (Ctrl-C) gracefully.
#
# Usage:
# ./this_script.sh
# Follow the menu prompts.
# --------------------------------------------------------------------
# by from your [ maaru 💘 ]

set -u
shopt -s nullglob

current_dir=$(dirname "$0")
styles_dir="$current_dir/styles"
search_dir="$styles_dir"
node_modules="$current_dir/node_modules"
sass_source="$node_modules/.bin/sass"

main_css="$current_dir/main.css"
main_css_map="${main_css}.map"
root_import="$current_dir/styles/import.sass"
use_char="_import.sass"
use_import_sass="@use"
sleep_timeout=0.03

RED=$'\e[31m';
GREEN=$'\e[32m';
YELLOW=$'\e[33m';
CYAN=$'\e[36m';
RESET=$'\e[0m';
UNDERLINE=$'\e[4m';
RESET_UNDERLINE=$'\e[0m';
GREY=$'\e[90m';
MAGENTA=$'\e[35m';
LIGHTGREEN=$'\e[92m';
WHITE=$'\e[97m'

# safer realpath (works even if file not exist)
root_import_real=$(realpath -m "$root_import")
main_css_real=$(realpath -m "$main_css")

title="// ┌─┐┌─┐┌─┐┌─┐  ┌─┐┌┬┐┬ ┬┬  ┬┌┐┌┌─┐
// └─┐├─┤└─┐└─┐  └─┐ │ └┬┘│  │││││ ┬
// └─┘┴ ┴└─┘└─┘  └─┘ ┴  ┴ ┴─┘┴┘└┘└─┘
// ----------------------------------------"
footer="// ----------------------------------------"
after_foot="// ℹ️ This file is auto-generated by the Sass import builder script.\n//    ▶ Do not edit manually — put your imports in _import.sass of each component directory.\n"

print_line() { echo -e "${GREEN}───────────────────────────────────────────────────${RESET}"; }

# --------------------------------------------------------------------------------
# Functions
# --------------------------------------------------------------------------------
sass_import_handler() {
    local dir="$1"
    local file="$dir/$use_char"
    if [ -f "$file" ]; then
        local ns=$(basename "$dir")
        ns="${ns#_}"
        local rel_dir
        rel_dir=$(realpath --relative-to="$(dirname "$root_import")" "$dir")
        printf '%s "%s/import" as %s\n' "$use_import_sass" "$rel_dir" "$ns"
    fi
}

show_imports_animated() {
    [ -f "$root_import" ] || return
    while IFS= read -r line || [ -n "$line" ]; do
        if [[ "$line" =~ ^[[:space:]]*// ]]; then
            printf '%b%b\n' "${YELLOW}┃ ${RESET}${GREY}${line}${RESET}"
        elif [[ "$line" =~ ^[[:space:]]*(@use)[[:space:]]+\"([^\"]+)\"[[:space:]]+as[[:space:]]+([A-Za-z0-9_]+) ]]; then
            local kw=${BASH_REMATCH[1]}
            local path=${BASH_REMATCH[2]}
            local ns=${BASH_REMATCH[3]}
            printf '%b %b "%s" %b %s\n' "${YELLOW}┃${RESET}" "${MAGENTA}${kw}${RESET}" "${path}" "${MAGENTA}as${RESET}" "${ns}"
        else
            printf '%b\n' "${YELLOW}┃ ${RESET}$line"
        fi
        sleep "$sleep_timeout"
    done < "$root_import"
}

build_import() {
    clear
    mkdir -p "$(dirname "$root_import")"
    {
        echo "$title"
        echo
        for dir in "$search_dir"/_* "$search_dir"/*_; do
            [ -d "$dir" ] || continue
            base=$(basename "$dir")
            if { [[ "$base" == _* && "$base" != __* ]]; } || { [[ "$base" == *_ && "$base" != *__ ]]; }; then
                if [ -f "$dir/$use_char" ]; then
                    sass_import_handler "$dir"
                fi
            fi
        done
        echo
        echo "$footer"
        echo -e "$after_foot"
    } > "$root_import"

    echo -e "\n\n${CYAN}⚡ ✨ Rewritten file:${RESET} $root_import_real"
    print_line
    show_imports_animated
    print_line
}

from_to() {
    # builds imports and launches sass --watch
    build_import
    echo -e "\n${CYAN}🚀 ${MAGENTA}▶ Launching sass watch:${RESET}"
    echo -e "       ${CYAN}⤷${RESET} ${YELLOW}${UNDERLINE}$root_import_real${RESET_UNDERLINE}${RESET} ->"
    echo -e "         ${CYAN}⤷${RESET} ${YELLOW}${UNDERLINE}$main_css_real${RESET_UNDERLINE}${RESET}\n"

    # choose sass binary (allow system sass fallback)
    if command -v sass >/dev/null 2>&1; then
        command -v sass >/dev/null && sass --watch "$root_import_real":"$main_css_real"
    elif [ -x "$sass_source" ]; then
        "$sass_source" --watch "$root_import_real":"$main_css_real"
    else
        # fallback to npx
        npx sass --watch "$root_import_real":"$main_css_real"
    fi
}

print_menu() {
    echo
    local options=("⚡ Start compilation" "🔄 Rewrite imports and show" "🟢 Exit")
    for i in "${!options[@]}"; do
        local num=$((i+1))
        printf '%b%b%b %s%b\n' "$CYAN" "$num)" "$RESET" "${MAGENTA}${UNDERLINE}${options[$i]}${RESET_UNDERLINE}" "$RESET"
        sleep "$sleep_timeout"
    done
    echo
    printf "${YELLOW}Choose an option [1-3]: ${RESET}"
}

trap_handler() {
    if command -v jq >/dev/null 2>&1 && [ -f "$main_css_map" ]; then
        jq '.' "$main_css_map" > "${main_css_map}.tmp" 2>/dev/null && mv "${main_css_map}.tmp" "$main_css_map"
    fi
    echo
    print_line
    echo -e "${RED}🔴 Interrupted.${RESET}"
    exit 130
}
trap trap_handler INT

# --------------------------------------------------------------------------------
# Argument parsing & mode handling (MUST be before interactive menu)
# --------------------------------------------------------------------------------
watch_mode=false
replace_mode=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        -w|--watch)
            watch_mode=true
            shift
            ;;
        -r|--replace)
            replace_mode=true
            shift
            ;;
        -h|--help)
            echo "Usage: $0 [-w|--watch] [-r|--replace]"
            echo "  -w, --watch    Start sass watch compilation"
            echo "  -r, --replace  Rebuild import.sass and show imports"
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${RESET}"
            exit 1
            ;;
    esac
done

# If replace mode requested -> rebuild imports and exit
if [ "$replace_mode" = true ]; then
    build_import
    exit 0
fi

# If watch mode requested -> run build + from_to (then block until watch ends)
if [ "$watch_mode" = true ]; then
    # build_import is already called inside from_to; but we want title shown *as part* of flow
    from_to
    exit 0
fi

# --------------------------------------------------------------------------------
# No args -> interactive behaviour: show build first, then menu.
# If user picks 1 -> build + from_to
# --------------------------------------------------------------------------------
clear
build_import
while true; do
    print_menu
    if ! read -r choice; then
        echo -e "${RED}🔴 No input. Exiting.${RESET}"
        exit 1
    fi
    case "$choice" in
        1)
            from_to
            ;;
        2)
            build_import
            ;;
        3)
            echo -e "${GREEN}🟢 ✔ Exit.${RESET}"
            exit 0
            ;;
        *)
            clear
            echo -e "${RED}🔴 Invalid choice.${RESET}"
            ;;
    esac
done
